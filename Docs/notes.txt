L.Jose has used 3 metrics for sroting the table in their paper

1) Dependency: Now this is defined by the logical stage levels for the tables. In our system we at first assign appropriate logical stages for the logical MATs.
It implies that, a table with lengthy chain of ligical tables will have higher logical stage level. hence they will be assigned first. So in logical
stage level calculation the sorting is already implemented. therefore for the next two types of metrics we need  to do sorting when we embed the logical MAT according
on the physical stages.

2) Word width:

3) Memory Types:



our variations

a) only table - level -- no specific ordering of the tables in same level
b) prioritize tables with wider match fields.. implies both table level and match weidth is conbsidered
c) then prioritize action width. implies both table level and action weidth is conbsidered. suitable for programs where tables have smaller match width but high action width .



Resources used by an action :

a) header field being modified, being used and their bit width
b) number of stateful memories and their bitwodth
c) we will assume that, the extern also uses the same action crossbar



Another point :

if we have maximum 8 field matching capability in each stage, that means, we can continue at most 8 branch (resulted from conditional) in one stage
so ity should enough to store 8  bit in the pecial key for carrying the result of a conditional. so if we reserve 8 bits in this field, then whern we are embedding, at most
8 branches can be mapped on a stage. so assume we are embedding 8 conditionals, then we can index them from 1 to 8. then we can use this index to see which bit should be mapped
to which conditional.


Now assiging this bit to conditional is the task of a compiler. we lave it for future work.

also instead of full 8 bit match key, we should go for 1 bit + other keys of the table. that is also our future goal.


Stateful memory:

Assume, in each stage we have 32b wide memory port.
 Also assume we have a 32 bit wide register array and each stage can accomodate 2 Mb sram. Then each stage can accomodate 65K entries.
Now if we need 100K entries, then the device can spread the register array (which uses sram,) to  2 stages. first stage will contain 65k
and 2nd stage contain 35K. As the register is maintained as extern, it will maintain a range of index iteself. So basically we still need 32b
wide memory port, but the data structure spreads over 2 stages. Now in 2nd stage we have 30K*32b space remaining but the memory port of 2nd stage
is still unused. so another talble can use that.

In this way we can expand the register array to multiple stages.


but the inly concern here is, in the Fast forwarding metamorphosis paper, it says sram is attached to each stage. so the first stage can not access 2nd stage.
Now that is a trouble. we need to understand that.


--------------------- This trouble only happens in the case of indirect memory.

But if we use direct memory, then it is easy, it means each table entry has associated direct memory. so when we divide the table over multiple stages
we also automatically dividing the direct memory in same way.



---- The tofiuno hardware do not divide the indirect registers across stages. but direct registersns can be. we will support the direct registers later.