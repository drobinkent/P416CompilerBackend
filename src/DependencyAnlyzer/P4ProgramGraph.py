import logging
from enum import Enum
import sys

from DependencyAnlyzer.DefinitionConstants import PipelineID
from DependencyAnlyzer.PipelineGraph import PipelineGraph

sys.path.append("..")
import ConfigurationConstants as confConst



import networkx as nx
logger = logging.getLogger('P4ProgramGraph')
hdlr = logging.FileHandler(confConst.LOG_FILE_PATH )
hdlr.setLevel(logging.INFO)
formatter = logging.Formatter('[%(asctime)s] p%(process)s {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s','%m-%d %H:%M:%S')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logging.StreamHandler(stream=None)
logger.setLevel(logging.INFO)



class P4ProgramGraph:
    def __init__(self, parsedP4Program):
        '''
        This program loads the parsed Json object representation of a P4 program into a graph
        :param p4ProgramParserJsonObject: this is the object that is generated by parsing the P4 json for bmv2.
        '''
        self.pipelineIdToPipelineGraphMap = {}
        self.pipelineIdToPipelineMap = {}
        self.parsedP4Program = parsedP4Program
        self.pipelineIdToMultipleOf8BitWidthByHeadercount = {}
        self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields = {}

    def loadPipelines(self, hw):
        logger.info("Loading pipelines")
        if (len(self.parsedP4Program.pipelines) <= 0):
            logger.info("There is no pipelines found in the parsed Json representation. Exiting")
            exit(0)
        for pipeline in self.parsedP4Program.pipelines:
            if(pipeline.name == PipelineID.INGRESS_PIPELINE.value):
                newPipelineGraph = PipelineGraph(pipelineID=PipelineID.INGRESS_PIPELINE, pipeline = pipeline, actions= self.parsedP4Program.actions,parsedP4Program = self.parsedP4Program)
                self.pipelineIdToPipelineGraphMap[PipelineID.INGRESS_PIPELINE] = newPipelineGraph
                self.pipelineIdToPipelineMap[PipelineID.INGRESS_PIPELINE] = pipeline
                newPipelineGraph.preProcessPipelineGraph()
                # hw.embedP4ProgramAccordingToSingleMatrix(self)
            if(pipeline.name == PipelineID.EGRESS_PIPELINE.value):
                newPipelineGraph = PipelineGraph(pipelineID=PipelineID.EGRESS_PIPELINE, pipeline = pipeline, actions= self.parsedP4Program.actions,parsedP4Program = self.parsedP4Program)
                self.pipelineIdToPipelineGraphMap[PipelineID.EGRESS_PIPELINE] = newPipelineGraph
                self.pipelineIdToPipelineMap[PipelineID.EGRESS_PIPELINE] = pipeline
                newPipelineGraph.preProcessPipelineGraph()

    def embedPipelines(self, hw):
        logger.info("Embeding pipelines")
        if (len(self.parsedP4Program.pipelines) <= 0):
            logger.info("There is no pipelines found in the P4 program graph representation. Exiting")
            exit(0)
        for pipeline in self.parsedP4Program.pipelines:
            if(pipeline.name == PipelineID.INGRESS_PIPELINE.value):
                # newPipelineGraph = PipelineGraph(pipelineID=PipelineID.INGRESS_PIPELINE, pipeline = pipeline, actions= self.parsedP4Program.actions,parsedP4Program = self.parsedP4Program)
                # self.pipelineIdToPipelineGraphMap[PipelineID.INGRESS_PIPELINE] = newPipelineGraph
                # self.pipelineIdToPipelineMap[PipelineID.INGRESS_PIPELINE] = pipeline
                # newPipelineGraph.preProcessPipelineGraph()
                hw.embedP4ProgramAccordingToSingleMatrix(self,pipelineID=PipelineID.INGRESS_PIPELINE, hardware = hw)
            if(pipeline.name == PipelineID.EGRESS_PIPELINE.value):
                hw.embedP4ProgramAccordingToSingleMatrix(self,pipelineID=PipelineID.EGRESS_PIPELINE, hardware = hw)
                pass

    def headeranalyzer(self):
        # print(self.parsedP4Program.nameToHeaderTypeObjectMap)
        headerfieldListOfMetadata = None
        for hdrtype in self.parsedP4Program.header_types:
            if hdrtype.name == "standard_metadata":
                headerfieldListOfMetadata = self.parsedP4Program.buildHeaderVectorForGivenStruct(hdrtype.name, hdrtype)

        bitWidthByHeadercountForIngress = None
        bitWidthByHeadercountForEgress= None
        self.parsedP4Program.getTotalHeaderLength()
        if(self.pipelineIdToPipelineGraphMap.get(PipelineID.INGRESS_PIPELINE)  != None):
            print("\n\n Ingress stage header analysis")
            fullListOfHeaderFieldsUsedInIngressPipeline =set(self.pipelineIdToPipelineGraphMap.get(PipelineID.INGRESS_PIPELINE).headeranalyzerForSinglePipeline())
            headerFeildInStandardMEtadta = set(headerfieldListOfMetadata.keys())
            fullListOfHeaderFieldsUsedInIngressPipeline = fullListOfHeaderFieldsUsedInIngressPipeline.union(headerFeildInStandardMEtadta)
            self.getTotalHeaderLengthForHeaderFieldList(fullListOfHeaderFieldsUsedInIngressPipeline)
            bitWidthByHeadercountForIngress,bitWidthWiseHeaderFieldsForIngress = self.getHeaderCountByBitWidthForHeaderFieldList(fullListOfHeaderFieldsUsedInIngressPipeline)
            self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields[PipelineID.INGRESS_PIPELINE] = bitWidthWiseHeaderFieldsForIngress
            self.pipelineIdToMultipleOf8BitWidthByHeadercount[PipelineID.INGRESS_PIPELINE] = bitWidthByHeadercountForIngress
            print("Bitwdith wise header count is ",bitWidthByHeadercountForIngress)

        if(self.pipelineIdToPipelineGraphMap.get(PipelineID.EGRESS_PIPELINE)  != None):
            print("\n\n Egress stage header analysis")
            fullListOfHeaderFieldsUsedInEgressPipeline = set(self.pipelineIdToPipelineGraphMap.get(PipelineID.EGRESS_PIPELINE).headeranalyzerForSinglePipeline())
            headerFeildInStandardMEtadta = set(headerfieldListOfMetadata.keys())
            fullListOfHeaderFieldsUsedInEgressPipeline = fullListOfHeaderFieldsUsedInEgressPipeline.union(headerFeildInStandardMEtadta)
            self.getTotalHeaderLengthForHeaderFieldList(fullListOfHeaderFieldsUsedInEgressPipeline)
            bitWidthByHeadercountForEgress,bitWidthWiseHeaderFieldsForEgress = self.getHeaderCountByBitWidthForHeaderFieldList(fullListOfHeaderFieldsUsedInEgressPipeline)
            self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields[PipelineID.EGRESS_PIPELINE] = bitWidthWiseHeaderFieldsForEgress
            self.pipelineIdToMultipleOf8BitWidthByHeadercount[PipelineID.EGRESS_PIPELINE] = bitWidthByHeadercountForEgress
            print("Bitwdith wise header count is ",bitWidthByHeadercountForEgress)
        print("total header count in nameToHeaderTypeObjectMap is : "+str(len(self.parsedP4Program.nameToHeaderTypeObjectMap.keys())))
        # print("All elements in  nameToHeaderTypeObjectMap are: ")
        # for hf in self.parsedP4Program.nameToHeaderTypeObjectMap.keys():
        #     print("\t\t "+str(hf))


        mapToAppend = {}
        headerWidthSet = set()
        if(bitWidthByHeadercountForEgress != None):
            headerWidthSet = headerWidthSet.union(set(bitWidthByHeadercountForEgress.keys()))
        if(bitWidthByHeadercountForIngress != None):
            headerWidthSet = headerWidthSet.union(bitWidthByHeadercountForIngress.keys())

        bitWidthByHeadercountForStandardMetadata = {}
        setC= None



        for k in headerWidthSet:
            ingressObj = 0
            if(bitWidthByHeadercountForIngress != None):
                if(bitWidthByHeadercountForIngress.get(k) != None):
                    ingressObj = bitWidthByHeadercountForIngress.get(k)
            egressObj = 0
            if(bitWidthByHeadercountForEgress != None):
                if(bitWidthByHeadercountForEgress.get(k) != None):
                    egressObj = bitWidthByHeadercountForEgress.get(k)
            standardMEtadaObj = 0
            if(bitWidthByHeadercountForStandardMetadata.get(k) != None):
                standardMEtadaObj = bitWidthByHeadercountForStandardMetadata.get(k)
            mapToAppend[k] = ingressObj+egressObj+standardMEtadaObj
            # if(ingressObj == None):
            #     mapToAppend[k] = bitWidthByHeadercountForEgress.get(k)
            # else:
            #     bitWidthByHeadercountForEgress[k] = bitWidthByHeadercountForEgress.get(k) + ingressObj
        # for k in mapToAppend.keys():
        #     bitWidthByHeadercountForEgress[k] = mapToAppend.get(k)
        print("Bitwdith wise header count is ",mapToAppend)
        return  mapToAppend

    def getTotalHeaderLengthForHeaderFieldList(self, headerFieldList):
        total = 0
        for k in headerFieldList:
            hf = self.parsedP4Program.nameToHeaderTypeObjectMap.get(k)
            if (hf==None):
                flag = False
                for headerStruct in self.parsedP4Program.headers:
                    if(headerStruct.name == k):
                        flag = True
                        break
                    else:
                        flag = False
                if (flag == False):
                    logger.info("Field not found in map . The field is "+str(k))
            else:
                total = total + int(self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).bitWidth)
        print("Total header legnth for given headerfield list is ",total)
        return total

    def getHeaderCountByBitWidthForHeaderFieldList(self, headerFieldList):
        total = 0
        bitWidthByHeadercount = {}
        bitWidthWiseHeaderFields = {}
        for k in headerFieldList:
            hf = None
            if(type(k)!=str):
                hf = self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name)
            else:
                hf = self.parsedP4Program.nameToHeaderTypeObjectMap.get(k)
            if (hf==None):
                logger.info("Field not found in map . The field is "+str(k))
            else:
                if(type(k)!=str):
                    if(bitWidthByHeadercount.get(self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth) == None):
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = 1
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = [k.name]
                    else:
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = \
                            bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] + 1
                        fieldList = bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth]
                        fieldList.append(k.name)
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = fieldList

                else:
                    if (bitWidthByHeadercount.get(self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth) == None):
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = 1
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = [k]
                    else:
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] + 1
                        fieldList = bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth]
                        fieldList.append(k)
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = fieldList
        return bitWidthByHeadercount,bitWidthWiseHeaderFields

    def storePHVFieldMappingForHeaderFields(self,mappedPacketHeaderVector):
        for pipelineKey in self.pipelineIdToMultipleOf8BitWidthByHeadercount.keys():
            multipleOf8BitWiseHeaderFieldListMap = self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields.get(pipelineKey)
            for bitwidth in multipleOf8BitWiseHeaderFieldListMap.keys():
                headerFieldList = multipleOf8BitWiseHeaderFieldListMap.get(bitwidth)
                for headerFieldName in headerFieldList:
                    headerFieldObject = self.parsedP4Program.nameToHeaderTypeObjectMap.get(headerFieldName)
                    allPHVFieldListForBitWidth = mappedPacketHeaderVector.get(bitwidth)
                    mappedPHVList = []
                    headerbitWidth = bitwidth
                    while headerbitWidth>0:
                        poppedPhv = allPHVFieldListForBitWidth.pop()
                        mappedPHVList.append(poppedPhv)
                        headerbitWidth = headerbitWidth - poppedPhv
                    headerFieldObject.setPipelineIDToPHVListMap(pipelineKey,mappedPHVList)

        # for headerFieldName in  self.parsedP4Program.nameToHeaderTypeObjectMap.keys():
        #     for pipelineKey in self.pipelineIdToMultipleOf8BitWidthByHeadercount.keys():
        #         print("Name : "+str(headerFieldName)+" needs "+str(self.parsedP4Program.nameToHeaderTypeObjectMap.get(headerFieldName).mutlipleOf8Bitwidth)+" bits in piepeline "+str(pipelineKey)+". Saisfied by follwoing PHV: "+str(self.parsedP4Program.nameToHeaderTypeObjectMap.get(headerFieldName).getPipelineIDToPHVListMap(pipelineKey)))


        pass
