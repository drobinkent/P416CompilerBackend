import copy
import logging
from enum import Enum
import sys

import CompilerConfigurations
from DependencyAnlyzer.DefinitionConstants import PipelineID
from DependencyAnlyzer.PipelineGraph import PipelineGraph

sys.path.append("..")
import ConfigurationConstants as confConst



import networkx as nx
logger = logging.getLogger('P4ProgramGraph')
hdlr = logging.FileHandler(confConst.LOG_FILE_PATH )
hdlr.setLevel(logging.INFO)
formatter = logging.Formatter('[%(asctime)s] p%(process)s {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s','%m-%d %H:%M:%S')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logging.StreamHandler(stream=None)
logger.setLevel(logging.INFO)



class P4ProgramGraph:
    def __init__(self, parsedP4Program):
        '''
        This program loads the parsed Json object representation of a P4 program into a graph
        :param p4ProgramParserJsonObject: this is the object that is generated by parsing the P4 json for bmv2.
        '''
        self.pipelineIdToPipelineGraphMap = {}
        self.pipelineIdToPipelineMap = {}
        self.parsedP4Program = parsedP4Program
        self.pipelineIdToMultipleOf8BitWidthByHeadercount = {}
        self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields = {}


    # def analyzeActions(self):
    #     print("Inside action analyzer")
    #     for a in self.parsedP4Program.actions:
    #         a.
    #
    #     pass

    def checkExistenceOfDirectStatefulMemory(self):
        for c in self.parsedP4Program.nameToCounterArrayMap.values():
            if(c.is_direct == True):
                print("We do not suport direct counter at this moment. Can not compute mapping for this P4 program. Exiting!!")
                exit(1)
        for m in self.parsedP4Program.nameToMeterArrayMap.values():
            if(m.is_direct == True):
                print("We do not suport direct meter at this moment. Can not compute mapping for this P4 program. Exiting!!")
                exit(1)
        # for r in self.parsedP4Program.nameToMeterArrayMap:
        #     if(m.is_direct == True):
        #         print("We do not suport direct meter at this moment. Can not compute mapping for this P4 program. Exiting!!")
        #         exit(1)
        pass

    def checkActionCountForEachTable(self,hw):
        for pipieline in self.parsedP4Program.pipelines:
            for t in pipieline.tables:
                if(len(t.actions) > hw.hardwareSpecRawJsonObjects.stage_description[0].per_mat_instruction_memory_capacity):
                    print("The hardware can support onle "+str(hw.hardwareSpecRawJsonObjects.stage_description[0].per_mat_instruction_memory_capacity)+" actions per MAT.")
                    print("However the program reequires "+str(len(t.actions)) + " actions for "+str(t.name))
                    print("Can't map the P4 program exiting")
                    exit(1)
        pass

    def loadPipelines(self, hw):
        logger.info("Loading pipelines")
        print("Initial Checking")
        self.checkExistenceOfDirectStatefulMemory()
        self.checkActionCountForEachTable(hw)
        # self.analyzeActions()
        if (len(self.parsedP4Program.pipelines) <= 0):
            logger.info("There is no pipelines found in the parsed Json representation. Exiting")
            exit(0)
        for pipeline in self.parsedP4Program.pipelines:
            if(pipeline.name == PipelineID.INGRESS_PIPELINE.value):
                newPipelineGraph = PipelineGraph(pipelineID=PipelineID.INGRESS_PIPELINE, pipeline = pipeline, actions= self.parsedP4Program.actions,parsedP4Program = self.parsedP4Program)
                self.pipelineIdToPipelineGraphMap[PipelineID.INGRESS_PIPELINE] = newPipelineGraph
                self.pipelineIdToPipelineMap[PipelineID.INGRESS_PIPELINE] = pipeline
                newPipelineGraph.preProcessPipelineGraph(hw)
                # hw.embedP4ProgramAccordingToSingleMatrix(self)
            if(pipeline.name == PipelineID.EGRESS_PIPELINE.value):
                newPipelineGraph = PipelineGraph(pipelineID=PipelineID.EGRESS_PIPELINE, pipeline = pipeline, actions= self.parsedP4Program.actions,parsedP4Program = self.parsedP4Program)
                self.pipelineIdToPipelineGraphMap[PipelineID.EGRESS_PIPELINE] = newPipelineGraph
                self.pipelineIdToPipelineMap[PipelineID.EGRESS_PIPELINE] = pipeline
                newPipelineGraph.preProcessPipelineGraph(hw)

    def embedPipelines(self, hw):
        maxPhysicalStageIndexForIngress = -1
        maxPhysicalStageIndexForEgress =-1
        logger.info("Embeding pipelines")
        if (len(self.parsedP4Program.pipelines) <= 0):
            logger.info("There is no pipelines found in the P4 program graph representation. Exiting")
            exit(0)
        for pipeline in self.parsedP4Program.pipelines:
            if(pipeline.name == PipelineID.INGRESS_PIPELINE.value):
                # newPipelineGraph = PipelineGraph(pipelineID=PipelineID.INGRESS_PIPELINE, pipeline = pipeline, actions= self.parsedP4Program.actions,parsedP4Program = self.parsedP4Program)
                # self.pipelineIdToPipelineGraphMap[PipelineID.INGRESS_PIPELINE] = newPipelineGraph
                # self.pipelineIdToPipelineMap[PipelineID.INGRESS_PIPELINE] = pipeline
                # newPipelineGraph.preProcessPipelineGraph()
                maxPhysicalStageIndexForIngress = hw.embedP4ProgramAccordingToSingleMatrix(self,pipelineID=PipelineID.INGRESS_PIPELINE, hardware = hw)
                # hw.reinitializeResourcesForNewPiepeline()
            if(pipeline.name == PipelineID.EGRESS_PIPELINE.value):
                maxPhysicalStageIndexForEgress = hw.embedP4ProgramAccordingToSingleMatrix(self,pipelineID=PipelineID.EGRESS_PIPELINE, hardware = hw)
        maxPhysicalStageIndex = -1
        if(maxPhysicalStageIndexForEgress > maxPhysicalStageIndexForIngress):
            print("Total Stage requirement for the whole P4 program is "+str(maxPhysicalStageIndexForEgress))
            maxPhysicalStageIndex = maxPhysicalStageIndexForEgress
        else:
            print("Total Stage requirement for the whole P4 program is "+str(maxPhysicalStageIndexForIngress))
            maxPhysicalStageIndex = maxPhysicalStageIndexForIngress

        #Power calculation
        print("Calculating Power requirement")
        totalPower = 0
        totalTCAMBlockRequired = 0
        totalSRAMBlockRequired = 0
        for physicalStageIndex in range(0,maxPhysicalStageIndex):
            physicalStageResource = hw.stageWiseResources.get(physicalStageIndex)
            x = physicalStageResource.tcamMatResource.usedTcamMatBlocks * CompilerConfigurations.PER_TCAM_BLOCK_POWER_CONSUMPTION
            y= physicalStageResource.sramResource.usedSramBlocks * CompilerConfigurations.PER_SRAM_BLOCK_POWER_CONSUMPTION
            totalTCAMBlockRequired = totalTCAMBlockRequired + physicalStageResource.tcamMatResource.usedTcamMatBlocks
            totalSRAMBlockRequired = totalSRAMBlockRequired + physicalStageResource.sramResource.usedSramBlocks
            totalPower = totalPower + x + y
        print("TOTAL TCAM BLOCKS REQUIRED: "+str(totalTCAMBlockRequired)+" and SRAM BLOCKS REQUIRED : "+str(totalSRAMBlockRequired)+" To amap the P4 program on the given hardware")
        print("TOTAL POWER CONSUMPTION FOR THE SRAM AND TCAM BLOCKS IN ALL STAGE IS : "+str(totalPower)+" WATTS")

    def headeranalyzer(self,hw):
        # print(self.parsedP4Program.nameToHeaderTypeObjectMap)
        headerfieldListOfMetadata = None
        for hdrtype in self.parsedP4Program.header_types:
            if hdrtype.name == "standard_metadata":
                headerfieldListOfMetadata = self.parsedP4Program.buildHeaderVectorForGivenStruct(hdrtype.name, hdrtype,hw)

        bitWidthByHeadercountForIngress = None
        bitWidthByHeadercountForEgress= None
        self.parsedP4Program.getTotalHeaderLength()
        totalRawBitWidthForIngress= 0
        totalRawBitWidthForEgress = 0
        if(self.pipelineIdToPipelineGraphMap.get(PipelineID.INGRESS_PIPELINE)  != None):
            print("\n\n Ingress stage header analysis")
            fullListOfHeaderFieldsUsedInIngressPipeline =set(self.pipelineIdToPipelineGraphMap.get(PipelineID.INGRESS_PIPELINE).headeranalyzerForSinglePipeline())
            headerFeildInStandardMEtadta = set(headerfieldListOfMetadata.keys())
            fullListOfHeaderFieldsUsedInIngressPipeline = fullListOfHeaderFieldsUsedInIngressPipeline.union(headerFeildInStandardMEtadta)
            self.getTotalHeaderLengthForHeaderFieldList(fullListOfHeaderFieldsUsedInIngressPipeline)
            bitWidthByHeadercountForIngress,bitWidthWiseHeaderFieldsForIngress, totalRawBitWidthForIngress = self.getHeaderCountByBitWidthForHeaderFieldList(fullListOfHeaderFieldsUsedInIngressPipeline)
            self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields[PipelineID.INGRESS_PIPELINE] = bitWidthWiseHeaderFieldsForIngress
            self.pipelineIdToMultipleOf8BitWidthByHeadercount[PipelineID.INGRESS_PIPELINE] = bitWidthByHeadercountForIngress
            print("Bitwdith wise header count is ",bitWidthByHeadercountForIngress)

        if(self.pipelineIdToPipelineGraphMap.get(PipelineID.EGRESS_PIPELINE)  != None):
            print("\n\n Egress stage header analysis")
            fullListOfHeaderFieldsUsedInEgressPipeline = set(self.pipelineIdToPipelineGraphMap.get(PipelineID.EGRESS_PIPELINE).headeranalyzerForSinglePipeline())
            headerFeildInStandardMEtadta = set(headerfieldListOfMetadata.keys())
            fullListOfHeaderFieldsUsedInEgressPipeline = fullListOfHeaderFieldsUsedInEgressPipeline.union(headerFeildInStandardMEtadta)
            self.getTotalHeaderLengthForHeaderFieldList(fullListOfHeaderFieldsUsedInEgressPipeline)
            bitWidthByHeadercountForEgress,bitWidthWiseHeaderFieldsForEgress, totalRawBitWidthForEgress = self.getHeaderCountByBitWidthForHeaderFieldList(fullListOfHeaderFieldsUsedInEgressPipeline)
            self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields[PipelineID.EGRESS_PIPELINE] = bitWidthWiseHeaderFieldsForEgress
            self.pipelineIdToMultipleOf8BitWidthByHeadercount[PipelineID.EGRESS_PIPELINE] = bitWidthByHeadercountForEgress
            print("Bitwdith wise header count is ",bitWidthByHeadercountForEgress)
        print("total header count in nameToHeaderTypeObjectMap is : "+str(len(self.parsedP4Program.nameToHeaderTypeObjectMap.keys())))
        # print("All elements in  nameToHeaderTypeObjectMap are: ")
        # for hf in self.parsedP4Program.nameToHeaderTypeObjectMap.keys():
        #     print("\t\t "+str(hf))


        mapToAppend = {}
        headerWidthSet = set()
        if(bitWidthByHeadercountForEgress != None):
            headerWidthSet = headerWidthSet.union(set(bitWidthByHeadercountForEgress.keys()))
        if(bitWidthByHeadercountForIngress != None):
            headerWidthSet = headerWidthSet.union(bitWidthByHeadercountForIngress.keys())

        bitWidthByHeadercountForStandardMetadata = {}
        setC= None



        for k in headerWidthSet:
            ingressObj = 0
            if(bitWidthByHeadercountForIngress != None):
                if(bitWidthByHeadercountForIngress.get(k) != None):
                    ingressObj = bitWidthByHeadercountForIngress.get(k)
            egressObj = 0
            if(bitWidthByHeadercountForEgress != None):
                if(bitWidthByHeadercountForEgress.get(k) != None):
                    egressObj = bitWidthByHeadercountForEgress.get(k)
            standardMEtadaObj = 0
            if(bitWidthByHeadercountForStandardMetadata.get(k) != None):
                standardMEtadaObj = bitWidthByHeadercountForStandardMetadata.get(k)
            mapToAppend[k] = ingressObj+egressObj+standardMEtadaObj
            # if(ingressObj == None):
            #     mapToAppend[k] = bitWidthByHeadercountForEgress.get(k)
            # else:
            #     bitWidthByHeadercountForEgress[k] = bitWidthByHeadercountForEgress.get(k) + ingressObj
        # for k in mapToAppend.keys():
        #     bitWidthByHeadercountForEgress[k] = mapToAppend.get(k)
        print("Bitwdith wise header count is ",mapToAppend)
        return  mapToAppend, totalRawBitWidthForEgress+ totalRawBitWidthForIngress

    def getTotalHeaderLengthForHeaderFieldList(self, headerFieldList):
        total = 0
        for k in headerFieldList:
            hf = self.parsedP4Program.nameToHeaderTypeObjectMap.get(k)
            if (hf==None):
                flag = False
                for headerStruct in self.parsedP4Program.headers:
                    if(headerStruct.name == k):
                        flag = True
                        break
                    else:
                        flag = False
                if (flag == False):
                    logger.info("Field not found in map . The field is "+str(k))
            else:
                total = total + int(self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).bitWidth)
        print("Total header legnth for given headerfield list is ",total)
        return total

    def getHeaderCountByBitWidthForHeaderFieldList(self, headerFieldList):
        total = 0
        bitWidthByHeadercount = {}
        bitWidthWiseHeaderFields = {}
        totalRawBitWidth = 0
        for k in headerFieldList:
            hf = None
            if(type(k)!=str):
                hf = self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name)
            else:
                hf = self.parsedP4Program.nameToHeaderTypeObjectMap.get(k)
            if (hf==None):
                logger.info("Field not found in map . The field is "+str(k))
            else:
                totalRawBitWidth =totalRawBitWidth+ hf.bitWidth
                if(type(k)!=str):
                    if(bitWidthByHeadercount.get(self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth) == None):
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = 1
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = [k.name]
                    else:
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = \
                            bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] + 1
                        fieldList = bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth]
                        fieldList.append(k.name)
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k.name).mutlipleOf8Bitwidth] = fieldList

                else:
                    if (bitWidthByHeadercount.get(self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth) == None):
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = 1
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = [k]
                    else:
                        bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = bitWidthByHeadercount[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] + 1
                        fieldList = bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth]
                        fieldList.append(k)
                        bitWidthWiseHeaderFields[self.parsedP4Program.nameToHeaderTypeObjectMap.get(k).mutlipleOf8Bitwidth] = fieldList
        return bitWidthByHeadercount,bitWidthWiseHeaderFields,totalRawBitWidth

    def storePHVFieldMappingForHeaderFields(self,mappedPacketHeaderVector):
        mappedPacketHeaderVector = copy.deepcopy(mappedPacketHeaderVector)
        for pipelineKey in self.pipelineIdToMultipleOf8BitWidthByHeadercount.keys():
            multipleOf8BitWiseHeaderFieldListMap = self.pipelineIdToMultipleOf8bitwidthWiseHeaderFields.get(pipelineKey)
            for bitwidth in multipleOf8BitWiseHeaderFieldListMap.keys():
                headerFieldList = multipleOf8BitWiseHeaderFieldListMap.get(bitwidth)
                for headerFieldName in headerFieldList:
                    headerFieldObject = self.parsedP4Program.nameToHeaderTypeObjectMap.get(headerFieldName)
                    allPHVFieldListForBitWidth = mappedPacketHeaderVector.get(bitwidth)
                    mappedPHVList = []
                    headerbitWidth = bitwidth
                    while headerbitWidth>0:
                        poppedPhv = allPHVFieldListForBitWidth.pop()
                        mappedPHVList.append(poppedPhv)
                        headerbitWidth = headerbitWidth - poppedPhv
                    headerFieldObject.setPipelineIDToPHVListMap(pipelineKey,mappedPHVList)

        # for headerFieldName in  self.parsedP4Program.nameToHeaderTypeObjectMap.keys():
        #     for pipelineKey in self.pipelineIdToMultipleOf8BitWidthByHeadercount.keys():
        #         print("Name : "+str(headerFieldName)+" needs "+str(self.parsedP4Program.nameToHeaderTypeObjectMap.get(headerFieldName).mutlipleOf8Bitwidth)+" bits in piepeline "+str(pipelineKey)+". Saisfied by follwoing PHV: "+str(self.parsedP4Program.nameToHeaderTypeObjectMap.get(headerFieldName).getPipelineIDToPHVListMap(pipelineKey)))


        pass
