from DependencyAnlyzer.P4ProgramGraph import P4ProgramGraph
from P4ProgramParser.P416JsonParser import ParsedP416ProgramForV1ModelArchitecture
from P4ProgramParser.P4ProgramParserFactory import P4ProgramParserFactory
from ParserMapper.make_tcam import buildParserMapper
from RMTHardwareSimulator import RMTHardwareFactory
from util import loadP416JsonUsingAutoGeneratedJsonParser
from ParserMapper import HeaderLib
# from ParserMapper import *
# from ParserMapper import RefCount
# from P416JsonParser import  ParserOpOp
from utils import Util
import time

#64, 96, and 64 words of 8, 16, and 32b
p4ProgramParserFactory = P4ProgramParserFactory()
hw = RMTHardwareFactory.createRmtHardware(rmtHardwaRemodelName = "RMT_V1",
    instructionSetConfigurationJsonFile= "../Resources/HardwareConfigs/RMTV1ModelInstructions.json",
    hardwareSpecConfigurationJsonFile = "../Resources/HardwareConfigs/RMTV1model32Stages.json")
# p4program = p4ProgramParserFactory.getParsedP4Program(p4JsonFile="../Resources/P4ProgramsForPaper/QoSModifier/qos_modifier.json",p4VersionAndArchitecture="P416_V1_Model")
# p4program = p4ProgramParserFactory.getParsedP4Program(p4JsonFile="../Resources/P4ProgramsForPaper/L2L3Simple/l2l3Simple.json",p4VersionAndArchitecture="P416_V1_Model")
# p4program = p4ProgramParserFactory.getParsedP4Program(p4JsonFile="../Resources/P4ProgramsForPaper/L2L3Complex/l2l3complex.json",p4VersionAndArchitecture="P416_V1_Model")
p4program = p4ProgramParserFactory.getParsedP4Program(p4JsonFile="../Resources/P4ProgramsForPaper/P4anony/p4anony.json",p4VersionAndArchitecture="P416_V1_Model")


p4program.buildHeaderVector(hw)
p4ProgramGraph = P4ProgramGraph(p4program)
p4ProgramGraph.loadPipelines(hw)
headerFieldSpecsInP4ProgramToBeUsedForParserMapper, totalRawBitwidth = p4ProgramGraph.headeranalyzer(hw)
parseGraphHeaderList, parsedGraphHeaders, initHeader = HeaderLib.loadParseGraph(parserObject = p4program.parsers[0], p4ProgramGraph = p4ProgramGraph) # There is only one parser in v1model
start = int(round(time.time() * 1000))
buildParserMapper(parseGraphHeaderList, parsedGraphHeaders, hw, initHeader)
end = int(round(time.time() * 1000))
print("Total time required for parser TCAM entry generation is "+str(end-start)+" miliseconds")
print("==============================================================================")


p4ProgramGraph.loadPipelines(hw)
headerFieldSpecsInP4Program,totalRawBitwidth = p4ProgramGraph.headeranalyzer(hw)
# mappedPacketHeaderVector1 = hw.mapHeaderFieldsUsingGoogleOR(headerFieldSpecsInP4Program)
# headerFieldSpecsInP4Program = {33: 1, 16: 1} # this line is for test purpose
start = int(round(time.time() * 1000))
mappedPacketHeaderVector = hw.mapHeaderFields(headerFieldSpecsInP4Program)
end = int(round(time.time() * 1000))
print(mappedPacketHeaderVector)
print("Total time required for header vector mapping is "+str(end-start)+" miliseconds")
print("==============================================================================")
p4ProgramGraph.storePHVFieldMappingForHeaderFields(mappedPacketHeaderVector=mappedPacketHeaderVector)
Util.calculatePHVWaste(headerFieldSpecsInP4Program, mappedPacketHeaderVector,totalRawBitwidth)
start = int(round(time.time() * 1000))
p4ProgramGraph.embedPipelines(hw)
end = int(round(time.time() * 1000))
print("Total time required for TDG mapping is "+str(end-start)+" miliseconds")
print("Total Nodes in the TDG is: "+str(p4ProgramGraph.rawTDGNodeCount) )
print("Total Edges in the TDG is: "+str(p4ProgramGraph.rawTDGEdgeCount) )
hw.calculateTotalLatency(p4ProgramGraph, hw)



#===================== Upto here header mappign is done



