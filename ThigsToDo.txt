TCAMMatFieldCount etar asole meaning nai. eta full code theke tulte hobe

simiarly SRAM MAT er jonno


*) assyme Node has two child B and C.
B has two child





Notes:

1) we do not supprt parser stack
2) P4 14 is not fully backward comaptible
3) the bmv is also not backwardnot compatible in all cases
3) reinitializeResourcesForNewPiepeline ei function a action crossbar bitwodth amra 0 te reinitilize korchi eta bodh hoy maximum of existing tables hobe.
because for a ingress pipeline there can be n tables embedded on a stage. but only one will be executed at a time. so for ingress pipeline in worst
the maximum of the action bitwidth will be used. therefore for egress the rest will remain.


Our mapping algorithm
at first maps the mats that useing indirect stateful memories. so we have to explain this in mapping algo and we also have to explain the difference between direct
and indirect stateful memory usage


*) These two function sneed  closer look
self.allocateActionMemoryBitwidth(maxActionMemoryBitwidth) -- are we going to allocate
            self.allocateActionCrossbarBitwidth(maxActionCrossbarBitwidth)




**) How to handle counter and meter

indirect counter and meter support :
in Action class there is a function "getListOfStatefulMemoriesBeingUsed" here we are suporting only register read and write.
if we want to add counter and meter, we need to add suport for both of thm in this function. then it will add indirect counter and meter dependency in the TDG.

Direct meter and counter support:
These are connnected with a specific table entry. so there is no depndency with other table. so basically we do not need anything extra, only
in embedding an action we need to calculate what is their memory requirement and how much memory they do need as part of supporting the action.



*) memory usage optimization:
will look at later part. but only needs to handle two function improvement. the indirect stateful memory allocation and action emmory allocation. These two function needs to
utilize multi word packing to improve memory usage. Must also need to accomodate the amount of memory port use in action part of indirect and direct register


*) table embedding a direct stateful memory support in action is needed. it should be simple in implementation

*) our memory packing is not good. for example assume someone using a single register. our algorithm will allocate a whole block for it.
To solve that we ned to model a full memory layout. and need to decide where to keep which elements.

*) we are basically not allocating fixed amount of sram blocks for action. we are allocting them from totla sram blocks. need to
modify the hardwre description where we have said fixed number of sram blocks. also we are saying that we are using fixed number of sram blocks. but we can also support
per mat rule sram entries.


-------------------------- VVI things to do

a) memory packing--- simple check kore dao. jodi 20 bit hoy 80 bit block a 4 ta dhukabo. r packing factor name ekta paremter add koro. r bole dibo amra block granularity te sram allocation kori.
jhotapt implement koro. same thing korbo sram mat er jonno.
b) need to check can whether action memory bitwidth is crossing the memory bitwidth or not
c) direct stateful memory allocation is not done. add it.
d) checking register capability
e) dhori ekta stage a ram port ache, 8x80 bit. so 8 bit er extern thakte pare 80 ta. 16 biut er 40 ta. but at the end of the day we  need to make sure they confform the mempry port
constrinats. evabe bole dite hobe. R amra instruction set asole temon kono kaje use kortechina. just for later stage.
--then we need a function to convert the bitwidth size to size of the register extern. just like h eader mapping.

How we will handle memory

the memory packing is used. now to read some register assume the actual data is 35 bit wide. therefore it need two 32 or one 48 bit wide register.
at this moment we will not map to any register. But when we want to generate the instreuction we need to pass how many bits will be read from sram. and rest will be padding.
Therefore in the register read instruction we need to pass follwoing information: index, actual bitwidth to be read, and rest will be padding.
OR even more simply as we actually allocate sram enties in integral multiple of sram block width this will automatically gives us mapping to some register that is
actually padded. for exmaple a 90 bit wide register is packed with 3 sram block of 80 bit wide. therefore onle 2 entries can be stored in 2 sram width block.
NOw 180 bit requires three 64 bit wide reigster read operation. we can do that, or we can use whole 3*80 bit wide register. but as of now we do not know
how it is actually handled in hardware. so we do not consider the second varioation. Therefore, we consider the first variation and consider that 90 bit will be read from memory.
However there is a problem with this variation. For example, assume we need 32 bit wide register. Hence one 96 bit wide sram block can store three such entries.
Now if we use a whole 96b wide port then it is waste of memory port. However, it depends on whther a memory port can read from a sram block or multiple block.
If it can read from a single block only then to read a 32b wide entry we need the whole 96b wide port. so really waste.


Best possible option is to follwo open toffino style 8,16,32, and 1 bit wide. This will reduce memory waste. r amra bole dibo j padding jekhane kortechi tar bakita
waste hocche. memory optimization k amra future goal hisebe rakhchi. Now the issue becomes P4 language supports arbitrary length. So we do padding.

now we need to implement a method for converting a bitwidth to accomodate how to accomodate usnig these registers. once we get that, the total width is the
bitwidth required for that entry.

we will say two things happen : a ) due to rounding upto the register bidwidths a loss occurs b) due to block granularity memory allocation loss occurs . we keep this as future
goalq





==========================Latency calculation

for all node in a single stage set teir start time to 0.
for every physical stage caculate if their is any 1 cycel dependency among the nodes. if have then set their start time accordingly.
for example table a  and b are in same stage and they have successor or reverse match depndency. theirfore a will start at 0 and b will start at 1.
set in this way for all the tables embedded on every stage.

start form stage 1 (0 is initialized as previous pragraph). sort the tables in increasing order of their start time.
Take the table that start earliest and compute whther if it has any dependency with any node embedded in previous stage
and calculate what is it's possible start times. Also check its predeccsoro generated from tdg and find what is the possible start times.
maximum of them will be its possible start time.



ingress embed korar pore egress embed korar age reintitialize korte hobe -- shekhane shudhu action memory load ing er jonno used portwidth ta k 0 kora lagbe.
