TCAMMatFieldCount etar asole meaning nai. eta full code theke tulte hobe

simiarly SRAM MAT er jonno


*) assyme Node has two child B and C.
B has two child





Notes:

1) we do not supprt parser stack
2) P4 14 is not fully backward comaptible
3) the bmv is also not backwardnot compatible in all cases
3) reinitializeResourcesForNewPiepeline ei function a action crossbar bitwodth amra 0 te reinitilize korchi eta bodh hoy maximum of existing tables hobe.
because for a ingress pipeline there can be n tables embedded on a stage. but only one will be executed at a time. so for ingress pipeline in worst
the maximum of the action bitwidth will be used. therefore for egress the rest will remain.


Our mapping algorithm
at first maps the mats that useing indirect stateful memories. so we have to explain this in mapping algo and we also have to explain the difference between direct
and indirect stateful memory usage


*) These two function sneed  closer look
self.allocateActionMemoryBitwidth(maxActionMemoryBitwidth) -- are we going to allocate
            self.allocateActionCrossbarBitwidth(maxActionCrossbarBitwidth)




**) How to handle counter and meter

indirect counter and meter support :
in Action class there is a function "getListOfStatefulMemoriesBeingUsed" here we are suporting only register read and write.
if we want to add counter and meter, we need to add suport for both of thm in this function. then it will add indirect counter and meter dependency in the TDG.

Direct meter and counter support:
These are connnected with a specific table entry. so there is no depndency with other table. so basically we do not need anything extra, only
in embedding an action we need to calculate what is their memory requirement and how much memory they do need as part of supporting the action.



*) memory usage optimization:
will look at later part. but only needs to handle two function improvement. the indirect stateful memory allocation and action emmory allocation. These two function needs to
utilize multi word packing to improve memory usage


*) table embedding a direct stateful memory support in action is needed. it should be simple in implementation

*) our memory packing is not good. for example assume someone using a single register. our algorithm will allocate a whole block for it.
To solve that we ned to model a full memory layout. and need to decide where to keep which elements.

*) we are basically not allocating fixed amount of sram blocks for action. we are allocting them from totla sram blocks. need to
modify the hardwre description where we have said fixed number of sram blocks. also we are saying that we are using fixed number of sram blocks. but we can also support
per mat rule sram entries.




==========================Latency calculation

for all node in a single stage set teir start time to 0.
for every physical stage caculate if their is any 1 cycel dependency among the nodes. if have then set their start time accordingly.
for example table a  and b are in same stage and they have successor or reverse match depndency. theirfore a will start at 0 and b will start at 1.
set in this way for all the tables embedded on every stage.

start form stage 1 (0 is initialized as previous pragraph). sort the tables in increasing order of their start time.
Take the table that start earliest and compute whther if it has any dependency with any node embedded in previous stage
and calculate what is it's possible start times. Also check its predeccsoro generated from tdg and find what is the possible start times.
maximum of them will be its possible start time.